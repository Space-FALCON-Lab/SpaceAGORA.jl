//////////////////////////////////////////////////////////////////////////
// The Global Reference Atmospheric Model (GRAM) Framework
//
// No recipient of this code should forward copies outside of the United 
// States without explicit approval by NASA Marshall Space Flight Center.
// 
// Module: EarthGRAM
//////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cmath>
#include "BallisticTrajectory.h"
#include "EarthInputParameters.h"

using namespace std;

namespace GRAM {

//! \copydoc Profile::Profile()
BallisticTrajectory::BallisticTrajectory()
{
  deltaPosition.height = 10.0;
}

//! \copydoc Profile::Profile(const Profile& orig)
BallisticTrajectory::BallisticTrajectory(const BallisticTrajectory& orig) :
  Profile(orig)
{
  useTrajFile = orig.useTrajFile;
  initialPosition = orig.initialPosition;
  deltaPosition = orig.deltaPosition;
  numPoints = orig.numPoints;
  trajectoryFileName = orig.trajectoryFileName;
  trajectoryData = orig.trajectoryData;
}

//! \copydoc Profile::~Profile()
BallisticTrajectory::~BallisticTrajectory()
{
  trajectoryData.clear();
}

//! \fn  BallisticTrajectory::setCorrelator(StateCorrelator& corr)
//! \brief Set the state correlator.
//!
//! This object requires a StateCorrelator that has been subclassed for the 
//! specific planet.
//! \param corr A subclassed StateCorrelator object.

//! \fn  BallisticTrajectory::setMaximumHeight(greal height)
//! \brief Set the maximum height of the trajectory.
//!
//! The trajectory generated by this object rises and then falls. The maximum
//! height is used to implement this behavior.
//! \param height The maximum height of the trajectory.

//! \fn void BallisticTrajectory::setDeltaPosition(const Position& p)
//! \brief Sets the change in position of the trajectory.
//!
//! The position of a trajectory is computed as the initialPosition
//! plus i times the deltaPosition where i is the current step.
//! \param p A Position object.

//! \fn void BallisticTrajectory::setNumberOfPoints(int numPts)
//! \brief Sets the number of data points to generate in the trajectory.
//!
//! \param numPts The number of data points to generate.

//! \copydoc Profile::setInputParameters()
void BallisticTrajectory::setInputParameters(const InputParameters& params)
{
  // Make sure we have an atmosphere.
  if (atmosphere == nullptr) {
    throw(string("Error: No atmosphere model present in EphemerisProfile.\n"
      "       Call setAtmosphere() prior to calling setInputParameters().\n"
      "       This is an unrecoverable error."));
  }

  const EarthInputParameters& eParams = static_cast<const EarthInputParameters&>(params);

  isPlantoCentric = params.isPlanetoCentric;

  // If there is no traj file, then assume they will supply the position info.
  if (params.numberOfPositions > 0 || params.trajectoryFileName.empty()) {
    // Set the inital position
    Position initialPosition;
    initialPosition.height = params.initialHeight;
    initialPosition.setLatitudeDegrees(params.initialLatitude);
    initialPosition.setLongitude(params.initialLongitude, params.isEastLongitudePositiveOnInput);
    initialPosition.elapsedTime = 0.0;
    setInitialPosition(initialPosition);

    // Set the change in position
    Position deltaPosition;
    if (params.isEastLongitudePositiveOnInput) {
      deltaPosition.setLongitude(params.deltaLongitude);
    }
    else {
      deltaPosition.setLongitude(-params.deltaLongitude);
    }
    deltaPosition.setLatitudeDegrees(params.deltaLatitude);
    deltaPosition.height = abs(params.deltaHeight);
    deltaPosition.elapsedTime = params.deltaTime;
    setDeltaPosition(deltaPosition);

    // The number of data points in each trajectory
    setNumberOfPoints(params.numberOfPositions);

    if (eParams.maximumHeight != 0) {
      maxHeight = eParams.maximumHeight;
    }
    else {
      maxHeight = (eParams.numberOfPositions / 2) * params.deltaHeight + params.initialHeight;
    }
  }
  else {
    // If a traj file name is present, use it.
    setDataFile(params.trajectoryFileName);
  }
  
  // Pass the input parameters on to the atmosphere.
  atmosphere->setInputParameters(params);
}

//! \brief Set the trajectory data file and read the data.
//!
//! The specified trajectory file should contains the following fields separated by
//! whitespace (no commas): elapsed time in seconds, height in km, latitude in degrees,
//! and longitude in degrees.
//! \param fileName The location of the data.
void BallisticTrajectory::setDataFile(const std::string& fileName)
{
  try {
    // Make sure the traj vector is cleared out.
    trajectoryData.clear();

    // Save the file name.
    trajectoryFileName = fileName;
    // Open the file for reading.
    ifstream trajFile(trajectoryFileName);
    if (!trajFile.is_open()) {
      throw string("Unable to open file.");
    }

    // Look for the maximum height while reading positions.
    maxHeight = -9999999.9;

    // Read until the end of the file is reached.
    while (!trajFile.eof()) {
      Position p;
      // Read in a point.
      string lineBuffer = "";
      getline(trajFile, lineBuffer);

      // Replace CSV with space delimitted.
      replace(lineBuffer.begin(), lineBuffer.end(), ',', ' ');

      if (trajFile.bad()) {
        throw string("Unable to parse line after time = ") + to_string(trajectoryData.back().elapsedTime);
      }

      if (!lineBuffer.empty() && lineBuffer.find_first_not_of(" \t") != lineBuffer.npos) {
        istringstream lineInput(lineBuffer);
        lineInput >> p.elapsedTime >> p.height >> p.latitude >> p.longitude;
        if (!lineInput.fail()) {
          // Locate the maximum height.
          maxHeight = max(maxHeight, p.height);
          // Store the point.
          trajectoryData.push_back(p);
        }
        else {
          throw string("Unable to parse line: ") + lineBuffer;
        }
      }
    }

    // Close the trajectory file.
    trajFile.close();
    // Save the size of the data.
    numPoints = (int)trajectoryData.size();
    // Mark the source as coming from a traj file.
    useTrajFile = true;
  }
  catch (string msg) {
    throw(string("Error: BallisticTrajectory file loading error.\n       ") + msg
      + "\n       Trajectory file: " + trajectoryFileName
      + "\n       This is an unrecoverable error.");
  }
}

//! \brief Get inputs and run the model.
//!
//! This function will get the positional inputs for a trajectory,
//! provide those inputs to the atmosphere model, and store the outputs.
void BallisticTrajectory::generate()
{
  // Make sure we have an atmosphere to run.
  if (atmosphere == nullptr) {
    throw(string("Error: No atmosphere model present in EphemerisProfile.\n"
      "       Call setAtmosphere() prior to calling generate().\n"
      "       This is an unrecoverable error."));
  }

  // Make sure the profile data structure is cleared out.
  profile.clear();

  // Prime the deltas with the elapsed time.
  Position position;
  if (useTrajFile) {
    if (trajectoryData.size() > 1) {
      // Find the delta between the first two positions.
      getPosition(0, position);
      Position position2;
      getPosition(1, position2);
      position.elapsedTime = position2.elapsedTime - position.elapsedTime;
    }
    else {
      // Anomolous trajectory file.
      position.elapsedTime = 0.0;
    }
    // Only keep the elapsed time.
    position.height = 0.0;
    position.latitude = 0.0;
    position.longitude = 0.0;
  }
  else {
    // For generated trajectories, just use the delta provided.
    position.elapsedTime = deltaPosition.elapsedTime;
  }
  atmosphere->setDelta(position);

  // Assume the trajectory rises to an apex.  Start at the bottom.
  reachedApex = false;

  // Start the generation loop.
  int step = 0;
  while (step < numPoints) {
    // Get the next position
    getPosition(step, position);
    if (position.height < 0.0) {
      break;
    }

    // Give the position to the atmosphere.
    atmosphere->setPosition(position);

    // Run the model.
    atmosphere->update();
    AtmosphereState atmos = atmosphere->getAtmosphereState();

    // No correlations are performed on the way up.  Only after having reached the apex.
    if (reachedApex) {
      // Find the height during ascent that matches the descent height.
      const ProfileData& upData = getAscendingData(position.height);

      // Correlate the descent (current) position with the ascent position.
      correlator->updateCoefficients(upData.position, atmosphere->getPosition());
      correlator->correlate(upData.atmos, atmos);
    }
    else {
      // No correlations are performed on the way up.
      // But we will test to see if the apex has been reached.
      if (position.height >= maxHeight - 1.0e-7) {
        reachedApex = true;
        index = profile.size() - 1;
      }
    }

    // Store the results.
    profile.emplace_back(atmosphere->getPosition(), atmos, atmosphere->getEphemerisState() );
    ++step;
  }
}

//!  \brief Locate ascending data point near specified height.
//!
//! This function will locate ascending data point that is closest to the specified height.
//! The ascending data is assumed to be strictly increasing.
//!
//! \param height The desired height \units{km}.
//!
//! \returns The ascending ProfileData matching the specified height.
const ProfileData& BallisticTrajectory::getAscendingData(greal height) {
  // It is assumed that the data is now strictly decreasing.
  // So it is safe to start with the last recorded index.
  // Locate the index of the ascending point just below (or equal to) height.
  while (index > 0 && height < profile[index].position.height) {
    --index;
  }

  // Vertical distance between the upper bound and height
  greal dxUpper = profile[index + 1].position.height - height;

  // Vertical distance between the lower bound and height
  greal dxLower = height - profile[index].position.height;

  // If the upper bound is closer, then increment the index.
  if (dxUpper < dxLower) {
    ++index;
  }

  // Return the profile corresponding to the closest ascending height.
  return profile[index];
}

//! \brief Read or generate a position.
//!
//! A new position for the specified step will either be read from a trajectory file
//! or generated at a specified delta from the previous position.  A step value of -1
//! may be used to generate a position prior to the initial position.  Positions that
//! are generated using a specified delta must be generated in order.
//!
//! /param step The index of the point in the trajectory.
void BallisticTrajectory::getPosition(int step, Position& position)
{
  // When data is loaded from a trajectory file:
  if (useTrajFile) {
    position = trajectoryData.at(step);
    if (atmosphere->getInputParameters().isEastLongitudePositiveOnInput == false) {
      position.longitude = 360.0_deg - position.longitude;
    }
  }
  // When data is generated at fixed deltas:
  else {
    // Compute the next position (p = p0 + step * delta)
    // Special case for the initial position.
    if (step == 0) {
      position.longitude = initialPosition.longitude;
      position.latitude = initialPosition.latitude;
      position.height = initialPosition.height;
      position.elapsedTime = initialPosition.elapsedTime;
    }
    // Special case for position prior to initial position.
    else if (step == -1) {
      position.longitude = wrapDegrees(initialPosition.longitude - deltaPosition.longitude);
      position.latitude = initialPosition.latitude - deltaPosition.latitude;
      position.height = initialPosition.height - deltaPosition.height;
      position.elapsedTime = initialPosition.elapsedTime - deltaPosition.elapsedTime;
    }
    // General descent case add the delta to the current position.
    else if (reachedApex) {
      position.longitude = wrapDegrees(position.longitude + deltaPosition.longitude);
      position.latitude += deltaPosition.latitude;
      position.height -= deltaPosition.height;
      position.elapsedTime += deltaPosition.elapsedTime;
    }
    // General ascent case add the delta to the current position.
    else {
    position.longitude = wrapDegrees(position.longitude + deltaPosition.longitude);
    position.latitude += deltaPosition.latitude;
    position.height += deltaPosition.height;
    position.elapsedTime += deltaPosition.elapsedTime;
    }

    // Passage over the poles inverts the delta and flips the longitude.
    if (abs(position.latitude) > 90.0_deg) {
      position.latitude = copysign(180.0_deg, position.latitude) - position.latitude;
      position.longitude = wrapDegrees(position.longitude + 180.0_deg);
      deltaPosition.latitude *= -1.0;
    }
  }
  // Set the planetocentric flag
  position.isPlanetoCentric = isPlantoCentric;
}

} // namespace
