// Program to compute longwave and shortwave fluxes at surface and
// top of atmosphere of Mars. Longwave calculations are by the
// method of Savijarvi (1991). Shortwave fluxes are by delta-
// Eddington method.  Optionally, heating rates due to water vapor,
// carbon dioxide, and dust can also be calculated.
// Generated by Pacific-Sierra Research 77to90
// Translated to C++ 2021

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

double qrhtp(double a, double b, double c);
double emitt(double a, double b, double c);
double epsdust(double a);
double expr(double a);
double cp(double a);
void delted(double g, double om, double t, double amu0,
  double &rdif, double &tdif, double &rdir, double &tdd, double &tbeam);

constexpr double TO_RADIANS = (0.0174532925199432950);  // PI / 180

int main(int argc, char** argv)
{
  // Standard density of CO2 (at p = 1000 mb, T = 273 K)
  const double rhoco2 = 1.92;
  // Standard concentration for CO2 (% by volume)
  const double co2 = 95.3;
  // Reference pressure (mb) for scaled optical path lengths
  const double p0 = 1000.0;
  // Exponent for pressure scaling for optical path lengths
  const double expn = 0.75;
  // Constant rh (0-1) for water vapor concentration
  const double rh = 0.2;
  // Dust asymmetry parameter
  const double gdust = 0.7;
  // Dust single-scatter albedo
  const double omega0 = 0.9;
  // Solar constant (at 1AU), W/m**2
  const double e0 = 1367.0;
  // sigma = Stephan-Boltzmann constant
  const double sigma = 5.6704e-8;

  // Get the CSV file name
  cout << " Enter the csv file name (with extension): ";
  string fileName;
  cin >> fileName;

  ifstream csvFile(fileName);
  string line;
  getline(csvFile, line);

  ofstream listFile("Radlist.md");
  const size_t bufferSize = 1000;
  char buffer[bufferSize];
  buffer[0] = 0;

  ofstream outFile("Radout.csv");
  outFile << "ElapsedTime,  Height, Latitude, Longitude, albsfc, tau, RadAU,     mu0, ice,  Tsfc,"
    " Fusfc,  Tsky, Fdsfc, Teff,  Futoa, Edsfc, Eusfc, Edtoa, Eutoa,"
    " planalb, thet,  Tdif,  Tdir, Tbeam\n";

  // Set parameter to control output of heating rates
  int heatrate = 0;
  cout << " Enter 1 for heat rate calculations, 0 for none: ";
  cin >> heatrate;

  vector<double> p(500), t(500), gz(500), qdust(500), e(500), q(500), dtdt(500);
  bool readFlag = true;
  bool endOfData = false;
  int n = -1;
  double inElapsedTime = 0;
  double inHeight = 0;
  double inLatitude = 0;
  double inLongitude = 0;
  double elapsedTime = 0;
  double height = 0;
  double latitude = 0;
  double longitude = 0;
  double temperature = 0;
  double pressure = 0;
  double groundTemperature = 0;
  double dustOpticalDepth = 0; 
  double gravity = 0;
  double orbitalRadius = 0;
  double inAlbedo = 0;
  double solarZenithAngle = 0;
  double dustMixingRatio = 0;
  int iceIsPresent = 0;
  double ts = 0;
  double ufact = 0;
  double cfact = 0;
  double dustfact = 0;
  double thet = 0;
  double amu0 = 0;
  double e0mars = 0;
  double albedo = 0;
  double aumars = 0;
  int icepolar = 0;

  while (!endOfData) {
    while (csvFile.good()) { // read loop

      // Read data from Mars-GRAM CSV output
      if (readFlag) {
        getline(csvFile, line);
        if (!csvFile.good() || line.size() < 10) {
          endOfData = true;
          ++n;
          break;
        }
        vector<string> field;
        stringstream ss(line);
        string data;
        while (getline(ss, data, ',')) {
          field.push_back(data);
        }
        // Parse the fields
        inElapsedTime = stod(field[0]);
        inHeight = stod(field[1]);
        inLatitude = stod(field[2]);
        inLongitude = stod(field[3]);
        temperature = stod(field[7]);
        pressure = stod(field[8]) * 0.01;  // convert to mb
        groundTemperature = stod(field[109]);
        dustOpticalDepth = stod(field[117]);
        gravity = stod(field[6]);
        orbitalRadius = stod(field[49]);
        inAlbedo = stod(field[114]);
        solarZenithAngle = stod(field[47]);
        dustMixingRatio = stod(field[119]);
        iceIsPresent = stoi(field[122]);

        ++n;
        if (n >= (int)p.size()) {
          size_t size = p.size() + 500;
          p.resize(size);
          t.resize(size);
          gz.resize(size);
          qdust.resize(size);
          e.resize(size);
          q.resize(size);
          dtdt.resize(size);
        }
      }
      readFlag = true;

      if (n == 0) {
        if (groundTemperature > 900.0) {
          cout << " Bad surface temperature" << endl;
          exit(0);
        }
        if (iceIsPresent > 90) {
          cout << " Bad polar ice indicator" << endl;
          exit(0);
        }
        elapsedTime = inElapsedTime;
        height = inHeight;
        latitude = inLatitude;
        longitude = inLongitude;
      }
      if (n > 1 && pressure >= p[n - 1]) {
        break;
      }
      if (n == 1 && pressure >= p[0] && groundTemperature < 900.0) {
        n = 0;
        continue;
      }

      t[n] = temperature;
      p[n] = pressure;
      gz[n] = gravity;
      qdust[n] = dustMixingRatio;
      aumars = orbitalRadius;
      albedo = inAlbedo;
      amu0 = cos((solarZenithAngle)* (float)TO_RADIANS);
      amu0 = min(max(amu0, 0.0), 1.0);

      // Compute solar zenith angle (deg)
      thet = solarZenithAngle;
      if (groundTemperature < 900.0) ts = groundTemperature;
      if (iceIsPresent < 90) icepolar = iceIsPresent;

      // optical path factor for water vapor, optical paths in g/cm**2
      ufact = 1.0 / (100.0 * gravity);
      // optical path factor for CO2, optical paths in atm. cm
      cfact = 100.0 * (44.0 / 43.5) * co2 / (gravity * rhoco2);
      // dust optical path factor
      dustfact = 100.0 / (5.0e-3 * gravity);

      e0mars = e0 / (aumars * aumars);
      e[n] = sigma * pow(temperature, 4.0);
      q[n] = qrhtp(rh, temperature, pressure);

    } // end read loop

    p[n] = 0.0;
    t[n] = t[n - 1];
    dtdt[n] = 0.0;
    qdust[n] = 0.0;
    e[n] = e[n - 1];
    q[n] = 0.0;
    gz[n] = gz[n - 1];
    // Compute optical path lengths, uw(j) and uc(j) for each pressure
    // level, j = 1 to n, starting at the surface.
    vector<double> uw, uc, udust;
    uw.push_back(0.0);
    uc.push_back(0.0);
    udust.push_back(0.0);
    // LW flux from surface
    double egrnd = sigma * pow(ts, 4.0);
    for (int j = 0; j < n; ++j) {
      // Layer-average pressure
      double pj = 0.5 * (p[j] + p[j + 1]);
      // Layer-average water vapor mixing ratio
      double qj = 0.5 * (q[j] + q[j + 1]);
      // Pressure scaling factor for water vapor and CO2
      double scalfact = pow(pj / p0, expn);
      double deltap = p[j + 1] - p[j];
      // Layer-average dust mixing ratio
      double qdustj = 0.5 * (qdust[j] + qdust[j + 1]);
      double deltau = ufact * qj * deltap * scalfact;
      // water vapor optical path (g/cm**2)
      uw.push_back(uw[j] - deltau);
      // CO2 optical path (cm)
      uc.push_back(uc[j] - cfact * deltap * scalfact);
      // dust optical path
      udust.push_back(udust[j] - dustfact * deltap * qdustj);
    }

    // u1w, u1c = total optical path for water vapor and CO2.
    // double u1w = uw[n];
    double u1c = uc[n];

    // Step through each of the pressure levels, and compute integrals
    // for the upwelling and downwelling fluxes
    double airmass = 100.0;
    if (amu0 > 0.01) airmass = 1.0 / amu0;
    vector<double> fup, fdown, co2abs, fnet;
    for (int j = 0; j <= n; ++j) {
      fup.push_back(egrnd);
      fdown.push_back(0.0);
      co2abs.push_back(0.0021 * pow(abs(u1c - uc[j]) * airmass, 0.3));
      if (j != 0) {
        for (int k = 0; k < j; ++k) {
          double tkp = 0.5 * (t[k + 1] + t[j]);
          double epsk = emitt(uw[j] - uw[k], uc[j] - uc[k], tkp) + epsdust(udust[j] - udust[k]);
          double epskp = emitt(uw[j] - uw[k + 1], uc[j] - uc[k + 1], tkp) + epsdust(udust[j] - udust[k + 1]);
          fup[j] += 0.5 * (epskp + epsk) * (e[k + 1] - e[k]);
        }
      }
      if (j != n) {
        for (int k = n - 1; k >= j; --k) {
          double tkp = 0.5 * (t[k + 1] + t[j]);
          double epsk = emitt(uw[k] - uw[j], uc[k] - uc[j], tkp) + epsdust(udust[k] - udust[j]);
          double epskp = emitt(uw[k + 1] - uw[j], uc[k + 1] - uc[j], tkp) + epsdust(udust[k + 1] - udust[j]);
          fdown[j] += 0.5 * (e[k] + e[k + 1]) * (epskp - epsk);
        }
      }
      fnet.push_back(fup[j] - fdown[j]);
    }

    double femit = fdown[0] + fup.back() - fup[0];
    int marker = 0;
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %-11s | %-16s | %-11s |\n",
      "Field", "Value", "Field", "Value");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "|----------------------------|-------------|------------------|-------------|\n");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.2f | %-16s | %11.2f |\n",
      "Elapsed Time", elapsedTime,
      "Latitude", latitude);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.4f | %-16s | %11.2f |\n",
      "Height", height,
      "Longitude", longitude);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.2f | %-16s | %11.3f |\n"
      "| %-26s | %11.5f | %-16s | %11d |\n\n",
      "tau", dustOpticalDepth,
      "MarsAU", aumars, 
      "mu0", amu0, 
      "ice", icepolar);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %-11s | %-16s | %-11s |\n",
      "Longwave fluxes F (W/m^2)", "", "", "");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "|----------------------------|-------------|------------------|-------------|\n");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n",
      "Fdown(sfc)", fdown[0],
      "Fup(sfc)", fup[0]);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n\n",
      "Fup(toa)", fup[n],
      "Femit(atmos)", femit);

    listFile << buffer;
    marker = 0;
    buffer[0] = 0;

    double tsky = pow(fdown[0] / sigma, 0.25);
    double teff = pow(fup[n] / sigma, 0.25);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %-11s | %-16s | %-11s |\n",
      "Radiative temperatures (K)", "", "", "");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "|----------------------------|-------------|------------------|-------------|\n");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n",
      "Tsky(sfc)", tsky, "Tsfc", ts);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %-11s |\n\n",
      "Teff(toa)", teff, "", "");
      
    // Clear atmosphere increment for optical depth (Savijarvi, 1991)
    double tau = dustOpticalDepth + 0.0015;
    double rdif=0, tdif=0, rdir=0, tdir=0, tbeam=0;
    delted(gdust, omega0, tau, amu0, rdif, tdif, rdir, tdir, tbeam);
    double edntoa = e0mars * amu0;
    double albsurf = albedo;
    if (icepolar == 1) albsurf = 0.52;
    double ednsfc = edntoa * expr((-co2abs[0])) * (tbeam + tdir) / (1.0 - albsurf * rdif);
    if (icepolar == 1) {
      // Surface albedo for polar ice(Kieffer et al., Mars, 1992, page 1201)
      albsurf = 0.52 + 9.2e-4 * ednsfc;
      ednsfc = edntoa * expr((-co2abs[0])) * (tbeam + tdir) / (1.0 - albsurf * rdif);
    }
    double eupsfc = albsurf * ednsfc;
    double euptoa = edntoa * rdir + eupsfc * tdif;
    double eabsorb = edntoa - ednsfc + eupsfc - euptoa;
    double planalb = 0.0;
    if (edntoa > 0.0) planalb = euptoa / edntoa;

    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %-11s | %-16s | %-11s |\n",
      "Shortwave fluxes E (W/m^2)", "", "", "");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "|----------------------------|-------------|------------------|-------------|\n");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n",
      "Edown(sfc)", ednsfc,
      "Eup(sfc)", eupsfc);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n",
      "Eup(toa)", euptoa, 
      "Eabsorb(atmos)", eabsorb);

    listFile << buffer;
    marker = 0;
    buffer[0] = 0;

    if (thet > 90.0) {
      tdif = 0.0;
      tdir = 0.0;
      tbeam = 0.0;
    }

    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.3f |\n",
      "SZA(deg)", thet,
      "Tdif(sfc)", tdif);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.3f | %-16s | %11.3f |\n",
      "Tdir(sfc)", tdir, 
      "Tbeam(sfc)", tbeam);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.3f | %-16s | %11.3f |\n",
      "Surface albedo", albsurf, 
      "Planetary albedo", planalb);
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %-11s |\n\n",
      "Edown(toa)", edntoa, "", "");

    double abssfc = ednsfc + fdown[0] - eupsfc - fup[0];
    double emitspa = euptoa + fup.back();

    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %-11s | %-16s | %-11s |\n",
      "SW+LW (W/m^2)", "", "", "");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "|----------------------------|-------------|------------------|-------------|\n");
    marker += snprintf(buffer + marker, bufferSize - marker,
      "| %-26s | %11.1f | %-16s | %11.1f |\n\n",
      "Absorbed(sfc)", abssfc,
      "Emitted(toa)", emitspa);
    listFile << buffer;

    // Bypass heating rates if heatrate=0
    if (heatrate == 1) {
      // Compute longwave heating rate
      for (int j = 0; j < n; ++j) {
        dtdt[j] = 864.0 * (gz[j] / cp(t[j])) * (fnet[j] - fnet[j + 1]) / (p[j] - p[j + 1]);
      }
      // Write out optical path, broadband longwave fluxes, longwave,
      // shortwave, and total heating rates
      snprintf(buffer, bufferSize,
        "| Pres    | uH2O   | uCO2    | udust  | LWFup    | LWFdn    | LWFnet   | LWdTdt   | SWdTdt   | TotdTdt  |\n"
        "|---------|--------|---------|--------|----------|----------|----------|----------|----------|----------|\n"
        "| (mb)    | (mu.m) | (atmcm) |        | (W/m^2)  | (W/m^2)  | (W/m^2)  | (K/day)  | (K/day)  | (K/day)  |\n"
      );
      listFile << buffer;
      for (int j = 0; j < n; ++j) {
        double swdtdt = 0.0;
        if (tau > 0.0) {
          swdtdt = 864.0 * (gz[j] / cp(t[j])) * (edntoa * (co2abs[j + 1] - co2abs[j])
            - eabsorb * ((udust[j + 1] - udust[j]) / tau)) / (p[j + 1] - p[j]);
        }
        snprintf(buffer, bufferSize,
          "| %7.3f | %6.2f | %7.1f | %6.3f | %8.1f | %8.1f | %8.1f | %8.1f | %8.1f | %8.1f |\n",
          p[j], 10000.0*uw[j], uc[j], udust[j], fup[j], fdown[j], fnet[j],
          dtdt[j], swdtdt, swdtdt + dtdt[j]);
        listFile << buffer;
      }
    }
    snprintf(buffer, bufferSize, "%9.1f,%11.4f,%9.2f,%9.2f,%6.3f,%5.2f,%6.3f,%9.5f,%3d,%6.1f,%6.1f,%6.1f,%6.1f,"
      "%6.1f,%6.1f,%6.1f,%6.1f,%6.1f,%6.1f,%6.3f,%7.1f,%6.3f,%6.3f,%6.3f\n",
      elapsedTime, height, latitude, longitude, albsurf, dustOpticalDepth, aumars, amu0, icepolar, ts, fup[0], tsky, fdown[0],
      teff, fup[n], ednsfc, eupsfc, edntoa, euptoa, planalb, thet, tdif, tdir, tbeam);
    outFile << buffer;

    listFile << "\n------------------------------------------------------------------------\n\n";

    n = 0;
    readFlag = false;
  }
  cout << " Output written to files Radlist.md and Radout.csv" << endl;
  outFile.close();
  listFile.close();
}


// Specific heat at constant pressure, as function of temperature
// T in kelvins; Cp in joules kg**-1 K**-1
double cp(double T)
{
  double CP = 639.5 + (0.123687 + 0.00200225 * T) * T;
  return CP;
}

// Reflectance and transmittance for layer by Delta-Eddington
//    method (Joseph et al., J. Atmos. Sci., 33, 2452, 1976).
// Computes for both beam irradiance and diffuse irradiance at top
//    of layer.
// Inputs are:
//    g    = asymmetry factor
//    om   = single-scatter albedo
//    t    = vertically normalized optical depth for layer
//    amu0 = cosine solar zenith angle (for beam irradiance)
// Outputs are:
//    Rdif = diffuse reflectance for diffuse irradiance
//    Tdif = diffuse transmittance for diffuse irradiance
//    Rdir = diffuse reflectance for beam irradiance
//    Tdd  = diffuse transmittance for beam irradiance
//    Tbeam = beam transmittance
void delted(double g, double om, double t, double amu0,
  double &rdif, double &tdif, double &rdir, double &tdd, double &tbeam)
{
  rdif = 0.0;
  tdif = 1.0;
  rdir = 0.0;
  tdd = 1.0;
  tbeam = 1.0;

  if (amu0 <= 0.01) return;

  double small = 1.0e-42;
  double gp = g / (1.0 + g);
  tbeam = expr((-t / amu0));
  double g_2 = g * g;
  double ts = (1.0 - om * g_2) * t;
  double omp = (1.0 - g_2) * om / (1.0 - om * g_2);
  double ak_2 = 3.0 * (1.0 - omp)*(1.0 - omp * gp);
  double ak = sqrt(ak_2);
  double p = sqrt(3.0 * (1.0 - omp) / (1.0 - omp * gp));
  double et = expr(ts * ak);
  double etm = 1.0 / et;
  double emu = expr((-ts / amu0));
  double amu0_2 = amu0 * amu0;
  double alfa = 3.0 * omp * amu0_2 * (1.0 + gp * (1.0 - omp)) / (4.0 * (1.0 - ak_2 * amu0_2));
  double beta = 3.0 * omp * amu0 * (1.0 + 3.0 * gp * (1.0 - omp) * amu0_2) / (4.0 * (1.0 - ak_2 * amu0_2));
  double am = alfa - 2.0 * beta / 3.0;
  double ap = alfa + 2.0 * beta / 3.0;
  double pp = 1.0 + 2.0 * p / 3.0;
  double pm = 1.0 - 2.0 * p / 3.0;
  rdif = pm / pp;
  rdif = max(0.0, rdif);
  tdif = 0.0;
  if (etm >= small) {
    double denom1 = pm * pm * etm - pp * pp * et;
    tdif = etm * (1.0 + pm * pm*(et - etm) / denom1);
    rdif = (pm / pp) * (1.0 + etm * (pp * pp - pm * pm) / denom1);
    rdif = max(0.0, rdif);
  }
  double denom2 = et * pp * pp - etm * pm * pm;
  double c2num = emu * am * pp - etm * pm * ap;
  double c2 = 0.0;
  if (abs(c2num) > small * abs(denom2)) c2 = c2num / denom2;
  double c1 = (ap - pm * c2) / pp;
  rdir = (pm * c1 + pp * c2 - am) / amu0;
  double tdir = (pp * c1 * etm + pm * c2 * et - (ap - amu0) * emu) / amu0;
  tdd = tdir - tbeam;
}

// Emittance due to CO2 path length uc (atm. cm) and
// temperature T (K), from Table 2 of Staley and Jurica, J. Appl.
// Meteorol., vol.9, p.365, 1970.
double epsilonc(double uc, double t)
{
// Emissivity tables in percent
  double ec[4][23] = {
    {0.114, 0.162, 0.247, 0.331, 0.439, 0.641, 0.859, 1.19, 1.92, 2.78, 3.92,
     5.76, 7.19, 8.60, 10.4, 11.7, 13.0, 14.7, 15.9, 17.0, 18.6, 19.7, 20.7},
    {0.119, 0.171, 0.262, 0.354, 0.471, 0.691, 0.928, 1.29, 2.08, 3.03, 4.30,
     6.36, 7.99, 9.61, 11.7, 13.3, 14.8, 16.7, 18.1, 19.5, 21.3, 22.6, 23.9},
    {0.115, 0.167, 0.260, 0.352, 0.471, 0.693, 0.934, 1.30, 2.11, 3.08, 4.39,
     6.54, 8.26, 10.0, 12.3, 13.9, 15.6, 17.7, 19.3, 20.7, 22.7, 24.1, 25.4},
    {0.108, 0.158, 0.248, 0.338, 0.454, 0.672, 0.907, 1.27, 2.07, 3.03, 4.32,
     6.49, 8.23, 10.0, 12.4, 14.1, 15.8, 18.0, 19.6, 21.1, 23.1, 24.4, 25.7}
  };
  double alc[23] = { -4.0, -3.7, -3.3, -3.0, -2.7, -2.3, -2.0, -1.7, -1.3,
     -1.0, -0.7, -0.3, 0.0, 0.3, 0.7, 1.0, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0, 3.3 };

  double ti[4] = { 203.15, 233.15, 263.15, 293.15 };

  if (uc <= 0.0) {
    return 0.0;
  }
  double al = log10(uc);
  int i = 0;
  if (al < alc[0]) {
    i = 0;
  }
  else if (al > alc[21]) {
    i = 21;
  }
  else {
    for (int m = 1; m < 23; ++m) {
      if (al < alc[m]) {
        i = m - 1;
        break;
      }
    }
  }
  int j = 0;
  if (t > ti[1]) j = 1;
  if (t > ti[2]) j = 2;
  double eci[2];
  eci[0] = ec[j][i]     + (al - alc[i]) * (ec[j][i + 1]     - ec[j][i]    ) / (alc[i + 1] - alc[i]);
  eci[1] = ec[j + 1][i] + (al - alc[i]) * (ec[j + 1][i + 1] - ec[j + 1][i]) / (alc[i + 1] - alc[i]);
  double epc = eci[0] + (t - ti[j]) * (eci[1] - eci[0]) / (ti[j+ 1] - ti[j]);
  epc = max(0.0, epc);
  epc = min(100.0, epc);
  return epc / 100.0;
}

// Emittance due to H2O path length uw (g / cm**2) and
// temperature T (K), from Table 1 of Staley and Jurica, J. Appl.
// Meteorol., vol.9, p.365, 1970.
double epsilonw(double uw, double t)
{
  //  Emissivity tables in percent
  double ew[4][21] = { {2.16, 3.16, 5.11, 7.16, 9.77, 14.1, 18.0, 22.3, 28.3, 32.6, 36.8,
                       42.2, 46.2, 50.2, 56.0, 61.1, 67.3, 77.4, 85.3, 91.5, 95.8},
                      {1.90, 2.72, 4.40, 6.16, 8.41, 12.2, 15.7, 19.6, 25.1, 29.2, 33.3,
                       38.8, 42.8, 47.1, 53.4, 59.1, 66.2, 77.8, 86.8, 93.8, 98.0},
                      {1.86, 2.58, 4.11, 5.72, 7.81, 11.4, 14.6, 18.3, 23.6, 27.7, 31.9,
                       37.4, 41.7, 46.2, 52.9, 59.0, 66.6, 78.8, 88.1, 95.1, 98.8},
                      {1.96, 2.62, 4.09, 5.65, 7.68, 11.2, 14.3, 18.0, 23.2, 27.3, 31.6,
                       37.3, 41.8, 46.5, 53.6, 60.0, 67.7, 79.8, 88.8, 95.4, 98.7} };

  double alw[21] = { -5.0, -4.7, -4.3, -4.0, -3.7, -3.3, -3.0, -2.7, -2.3, -2.0, -1.7,
                    -1.3, -1.0, -0.7, -0.3, 0.0,  0.3,  0.7,  1.0,  1.3,  1.7 };

  double ti[4] = { 203.15, 233.15, 263.15, 293.15 };

  if (uw <= 0.0) {
    return 0.0;
  }
  double al = log10(uw);
  int i = 0;
  if (al < alw[0]) {
    i = 0;
  }
  else if (al > alw[19]) {
    i = 19;
  }
  else {
    for (int m = 1; m < 21; ++m) {
      if (al < alw[m]) {
        i = m - 1;
        break;
      }
    }
  }
  int j = 0;
  if (t > ti[1]) j = 1;
  if (t > ti[2]) j = 2;
  double ewi[2];
  ewi[0] = ew[j][i] + (al - alw[i]) * (ew[j][i + 1] - ew[j][i]) / (alw[i + 1] - alw[i]);
  ewi[1] = ew[j + 1][i] + (al - alw[i]) * (ew[j + 1][i + 1] - ew[j + 1][i]) / (alw[i + 1] - alw[i]);
  double epw = ewi[0] + (t - ti[j]) * (ewi[1] - ewi[0]) / (ti[j + 1] - ti[j]);
  epw = max(0.0, epw);
  epw = min(100.0, epw);
  return epw / 100.0;
}

// Emittance from combined CO2 and water vapor
double emitt(double uw, double uc, double t)
{
  double epsc = epsilonc(uc, t);
  double epsw = epsilonw(uw, t);
  return epsw + epsc - epsw * epsc;
}


// Longwave emittance from dust as a function of solar optical depth
// (tau)by the method of Haberle et al., Icarus, vol. 50, p.322,
// 1982 (Table II)
double epsdust(double tau)
{
  double c[5] = { -2.365e-4, 2.082e-1, 6.409e-2, -4.700e-2, 7.217e-3 };
  double altau = log(1.0 + tau);
  return (((c[4] * altau + c[3]) * altau + c[2]) * altau + c[1]) * altau + c[0];
}

// Special exponential function exp(x) which avoids arithmetic
// overflow at large x or arithmetic underflow at small x
double expr(double X)
{
  double BIG = 85.0;
  double EX;
  if (abs(X) > BIG) {
    EX = exp(copysign(1.0, X) * BIG);
  }
  else {
    EX = exp(X);
  }
  return EX;
}

// Specific humidity q(g / kg) versus RH(0 - 1), temperature(K), and
// pressure(mb) (Savijarvi, Contr.Atmos.Phys., 64, 103, 1991)
double qrhtp(double rh, double t, double p)
{
  // Saturation water vapor pressure es vs temperature T
  double es = 6.1135 * exp(22.542 * (t - 273.16) / (t + 0.32));
  return 1000.0 * rh * 0.407 * es / (p - 0.59 * es);
}
