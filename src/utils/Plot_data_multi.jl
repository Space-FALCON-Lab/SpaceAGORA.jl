include("Misc.jl")

using PlotlyJS
using PlotlyJS: scatter
using PlotlyJS: plot
using PlotlyJS: surface
using PlotlyJS: Layout
using LaTeXStrings
using Arrow
using DashBase: set_props!
using Dash, DashHtmlComponents, DashCoreComponents

#helper function for pushing PlotLY plots to dashboard
function maybe_push!(args, comp_id::String, traces, layout; also_return::Bool=true)
    fig = figure_dict(traces, layout)
    if haskey(args, :app) && !isnothing(get(args, :app, nothing))
        set_props!(args[:app], comp_id, Dict("figure" => fig))
    end
    return also_return ? fig : nothing
end

# push full figure (initial)
function push_figure!(args, comp_id::String, traces, layout)
    figs = ensure_cache!(args)
    fig = Dict("data" => (traces isa AbstractVector ? traces : [traces]),
               "layout" => layout)
    figs[comp_id] = fig
    set_props!(args[:app], comp_id, Dict("figure" => fig))
    return fig
end

# append a trace to an existing figure
function append_trace!(args, comp_id::String, new_trace)
    figs = ensure_cache!(args)
    fig = get(figs, comp_id, Dict("data"=>Any[], "layout"=>Layout()))  # default if missing
    data = get(fig, "data", Any[])
    push!(data, new_trace)
    fig["data"] = data
    figs[comp_id] = fig
    set_props!(args[:app], comp_id, Dict("figure" => fig))
    return fig
end

using Dash, PlotlyJS
using DashBase: set_props!

# --- tiny helpers ----------------------------------------------------------
function ensure_cache!(args)
    haskey(args, :fig_cache) || (args[:fig_cache] = Dict{String, Dict}())
    return args[:fig_cache]::Dict{String, Dict}
end

# Create or append a trace to an existing Dash graph (by id).
# If the graph doesn't exist, it initializes with `base_traces` + `new_trace` and `layout`.
function upsert_trace!(args, comp_id::String; base_traces=Any[], new_trace=nothing, layout=Layout())
    figs = ensure_cache!(args)

    if !haskey(figs, comp_id)
        # initialize
        data = Any[]
        append!(data, base_traces)
        if new_trace !== nothing
            push!(data, new_trace)
        end
        fig = Dict("data" => data, "layout" => layout)
        figs[comp_id] = fig
        set_props!(args[:app], comp_id, Dict("figure" => fig))
        return fig
    else
        # append to existing
        fig = figs[comp_id]
        data = get(fig, "data", Any[])
        if new_trace !== nothing
            push!(data, new_trace)
            fig["data"] = data
        end
        # (optionally merge layout updates here if you pass them)
        if haskey(args, :app) && !isnothing(get(args, :app, nothing))
            set_props!(args[:app], comp_id, Dict("figure" => fig))
        end
        return fig
    end
end


function plots_multi(aerobraking_outputs)
    # Unpack aerobraking_outputs
    state = aerobraking_outputs[:state]
    m = aerobraking_outputs[:m]
    name = aerobraking_outputs[:name]
    args = aerobraking_outputs[:args]
    temp_name = aerobraking_outputs[:temp_name]

    # Find all Arrow files generated by the simulation for this run
    arrow_files = filter(f -> endswith(f, ".arrow"), readdir(dirname(temp_name); join=true))
    data_tables = Dict{String, DataFrame}()

    for file in arrow_files
        # Extract spacecraft id from filename (assumes format: ..._<spacecraft_id>.arrow)
        fname = basename(file)
        parts = split(fname, "_")
        # Assuming spacecraft id is the last part before ".arrow"
        id = split(parts[end], ".")[1]
        data_tables[id] = DataFrame(Arrow.Table(file))
        println("Loaded Arrow table for spacecraft id '$id': $file with $(nrow(data_tables[id])) rows and $(ncol(data_tables[id])) columns.")
    end

    # For backward compatibility, pick the first table as 'data_table'
    # data_table = first(values(data_tables))

    if args[:keplerian] == true
        traj_3D(state, m, name, args, data_tables)
        traj_2D(state, m, name, args, data_tables)
    else
        # traj_3D(state, m, name, args)
        traj_2D(state, m, name, args, data_tables)
        performance_plots(state, m, name, args, data_tables)
    end

    # ABM_periapsis(name)
    # ground_track(state, m, name, args, data_tables)
    
    if args[:closed_form] == 1 && args[:body_shape] == "Spacecraft" && !config.cnf.impact && args[:keplerian] == false
        closed_form_solution_plot(name, m, data_tables)
        angle_of_attack_plot(name, args, data_tables)
    end

    if args[:type_of_mission] == "Drag Passage"
        drag_passage_plot(name, args, data_tables)
    end

    if args[:orientation_sim]
        attitude_plot(name, args, data_tables)
        quaternion_plot(name, data_tables)
        angular_velocity_plot(name, data_tables)
        wind_relative_attitude_plot(name, args, data_tables)
        torque_plot(name, data_tables)
        inertia_plot(name, data_tables)
        if m.body.n_reaction_wheels > 0
            reaction_wheel_h_plot(name, data_tables)
            reaction_wheel_torque_plot(name, data_tables)
            total_reaction_wheel_torque_plot(name, data_tables)
        end
    end
end

function drag_passage_plot(name::Dict, args::Dict, data_table::Dict)
    # Collect spacecraft ids
    ids = collect(keys(data_table))

    # Colors for each spacecraft
    colors = ["black", "red", "blue", "green", "orange", "purple", "cyan", "magenta", "yellow"]
    
    # --- α [deg] plot ---
    aoa_traces = []
    for (i, id) in enumerate(ids)
        # Use args[id], data_table[id], name[id]
        alt_idx = findall(x -> x < args[id][:AE]*1e3, config.solution.orientation.alt)
        time = [config.solution.orientation.time[j] for j in alt_idx]
        aoa = [rad2deg(config.solution.physical_properties.α_control[j]) for j in alt_idx]
        push!(aoa_traces, scatter(x=time, y=aoa, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="α $id"))
    end
    layout_aoa = Layout(yaxis_title="α [deg]", template="simple_white", showlegend=true)
    p_aoa = plot(aoa_traces, layout_aoa)

    # --- Heat Rate plot ---
    heatrate_traces = []
    for (i, id) in enumerate(ids)
        index = findall(x -> x > 0, config.solution.performance.heat_rate)
        time = [config.solution.orientation.time[j] for j in index]
        heat_rate = config.solution.performance.heat_rate[index]
        push!(heatrate_traces, scatter(x=time, y=heat_rate, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Heat Rate $id"))
    end
    layout_heatrate = Layout(yaxis_title="Heat Rate [W/cm²]", template="simple_white", showlegend=true)
    p_heatrate = plot(heatrate_traces, layout_heatrate)

    # --- Heat Load plot ---
    heatload_traces = []
    for (i, id) in enumerate(ids)
        index = findall(x -> x > 0, config.solution.performance.heat_rate)
        time = [config.solution.orientation.time[j] for j in index]
        heat_load = [config.solution.performance.heat_load[j] for j in index]
        push!(heatload_traces, scatter(x=time, y=heat_load, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Heat Load $id"))
    end
    layout_heatload = Layout(xaxis_title="Time [s]", yaxis_title="Heat Load [J/cm²]", template="simple_white", showlegend=true)
    p_heatload = plot(heatload_traces, layout_heatload)

    # Combine plots
    p = [p_aoa; p_heatrate; p_heatload]
    relayout!(p, width=2200, height=1000, template="simple_white", showlegend=true)
    display(p)
    savefig(p, "multi_drag_passage.pdf", format="pdf")

    # --- Altitude profile plot ---
    alt_traces = []
    for (i, id) in enumerate(ids)
        alt_idx = findall(x -> x < args[id][:AE]*1e3, config.solution.orientation.alt)
        time = [config.solution.orientation.time[j] for j in alt_idx]
        alt = [config.solution.orientation.alt[j] for j in alt_idx]
        push!(alt_traces, scatter(x=time, y=alt, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Altitude $id"))
    end
    layout_alt = Layout(xaxis_title="Time [s]", yaxis_title="Altitude [m]", template="simple_white", showlegend=true)
    p1 = plot(alt_traces, layout_alt)
    display(p1)
    savefig(p1, "multi_altitude_profile.pdf", format="pdf")
end

function angle_of_attack_plot(name::Dict, args::Dict, data_table::Dict)
    ids = collect(keys(data_table))
    colors = ["black", "red", "blue", "green", "orange", "purple", "cyan", "magenta", "yellow"]
    plots_aoa_line = []
    plots_aoa_mark = []

    for (i, id) in enumerate(ids)
        dt = data_table[id]
        arg = args[id]
        alt_idx = findall(x -> x < arg[:AE]*1e3, dt.alt)
        if isempty(alt_idx)
            continue
        end
        index_orbit = [1]
        time_0 = [dt.time[alt_idx[1]]]

        for j in range(start=2, step=1, stop=length(alt_idx))
            if alt_idx[j] - alt_idx[j - 1] > 2
                append!(index_orbit, j)
                append!(time_0, dt.time[alt_idx[j-1]])
            end
        end
        append!(index_orbit, length(alt_idx))

        if length(index_orbit) <= 2 # Only 1 orbit
            time = [dt.time[k] for k in alt_idx]
            aoa = [rad2deg(dt.aoa_control[k]) for k in alt_idx]
            push!(plots_aoa_line, scatter(x=time, y=aoa, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="α $id"))
        else
            for j in range(start=1, step=1, stop=length(index_orbit)-1)
                time = [dt.time[k] for k in alt_idx[index_orbit[j]:index_orbit[j+1]-1]]
                aoa = [rad2deg(dt.aoa_control[k]) for k in alt_idx[index_orbit[j]:index_orbit[j+1]-1]]
                push!(plots_aoa_mark, scatter(x=[j], y=[aoa[end]], mode="markers", marker=attr(color=colors[i % length(colors) + 1]), name="α $id end"))
                push!(plots_aoa_line, scatter(x=(time .- time[1])./(time[end] - time[1]) .+ (j-1), y=aoa, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="α $id"))
            end
        end
    end

    layout = Layout(xaxis_title="Orbits", yaxis_title="α [deg]", template="simple_white", showlegend=true)
    p = plot([plots_aoa_line..., plots_aoa_mark...], layout)
    display(p)
    savefig(p, "multi_angle_of_attack_profile.pdf", format="pdf")
end

function closed_form_solution_plot(name::Dict, mission::Dict, data_table::Dict)
    ids = collect(keys(data_table))
    colors = ["black", "red", "blue", "green", "orange", "purple", "cyan", "magenta", "yellow"]

    plot_traces_alt = []
    plot_traces_gamma = []
    plot_traces_v = []

    plot_traces_alt_cf = []
    plot_traces_gamma_cf = []
    plot_traces_v_cf = []

    for i in range(start=1, step=1, stop=length(index_orbit)-1)
        time_end = 0

        time = [config.solution.orientation.time[j] - time_0[i] + time_end for j in alt_idx[index_orbit[i]:index_orbit[i+1]-1]]
        alt = [(config.solution.orientation.pos_ii_mag[j] - mission.planet.Rp_e)/1e3 for j in alt_idx[index_orbit[i]:index_orbit[i+1]-1]]
        gamma = [rad2deg(config.solution.orientation.γ_ii[j]) for j in alt_idx[index_orbit[i]:index_orbit[i+1]-1]]
        v = [config.solution.orientation.vel_ii_mag[j] for j in alt_idx[index_orbit[i]:index_orbit[i+1]-1]]

        time_cf = [config.solution.closed_form.t_cf[j] - time_0_cf[i] + time_end for j in alt_idx_cf[index_orbit_cf[i]:index_orbit_cf[i+1]-1]]
        alt_cf = [config.solution.closed_form.h_cf[j]/1e3 for j in alt_idx_cf[index_orbit_cf[i]:index_orbit_cf[i+1]-1]]
        gamma_cf = [rad2deg(config.solution.closed_form.γ_cf[j]) for j in alt_idx_cf[index_orbit_cf[i]:index_orbit_cf[i+1]-1]]
        v_cf = [config.solution.closed_form.v_cf[j] for j in alt_idx_cf[index_orbit_cf[i]:index_orbit_cf[i+1]-1]]

        push!(plot_traces_alt, scatter(x=time, y=alt, mode="lines", line=attr(color="black")))
        push!(plot_traces_gamma, scatter(x=time, y=gamma, mode="lines", line=attr(color="black")))
        push!(plot_traces_v, scatter(x=time, y=v, mode="lines", line=attr(color="black")))

        push!(plot_traces_alt_cf, scatter(x=time_cf, y=alt_cf, mode="lines", line=attr(color="gray")))
        push!(plot_traces_gamma_cf, scatter(x=time_cf, y=gamma_cf, mode="lines", line=attr(color="gray")))
        push!(plot_traces_v_cf, scatter(x=time_cf, y=v_cf, mode="lines", line=attr(color="gray")))
    end

    layout_alt = Layout(xaxis_title="Time [s]", yaxis_title="Altitude [km]")
    layout_gamma = Layout(xaxis_title="Time [s]", yaxis_title="γ [deg]")
    layout_v = Layout(xaxis_title="Time [s]", yaxis_title="Velocity [km/s]")

    p_alt = plot([plot_traces_alt..., plot_traces_alt_cf...], layout_alt)
    p_gamma = plot([plot_traces_gamma..., plot_traces_gamma_cf...], layout_gamma)
    p_v = plot([plot_traces_v..., plot_traces_v_cf...], layout_v)

    # p_alt = plot([plot_traces_alt...], layout_alt)
    # p_gamma = plot([plot_traces_gamma...], layout_gamma)
    # p_v = plot([plot_traces_v...], layout_v)

    p = [p_alt p_gamma p_v]
    relayout!(p, width=2200, height=1000, template="simple_white", showlegend=false)

    display(p)
    savefig(p, name * "_closed_form_solution.pdf", format="pdf")
end

function performance_plots(state, m, name::Dict, args::Dict, data_table::Dict)
    ids = collect(keys(data_table))
    colors = ["black", "red", "blue", "green", "orange", "purple", "cyan", "magenta", "yellow"]

    # --- Energy or Altitude plot ---
    plot_traces_1 = []
    layout_1 = nothing
    for (i, id) in enumerate(ids)
        dt = data_table[id]
        arg = args[id]
        if arg[:body_shape] == "Spacecraft"
            push!(plot_traces_1, scatter(x=[item/(60*60*24) for item in dt.time], y=[item * 1e-6 for item in dt.energy], mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Energy $id"))
            layout_1 = Layout(xaxis_title="Time [days]", yaxis_title="Energy [MJ/kg]")
        else
            index = findall(x -> x < (arg[:EI] + 100)*1e3, dt.alt)
            alt = dt.alt[index]
            if !isempty(index)
                time = [dt.time[j] for j in index]
                push!(plot_traces_1, scatter(x=time/(60*60*24), y=alt, mode="markers", marker=attr(color=colors[i % length(colors) + 1]), name="Altitude $id"))
                layout_1 = Layout(xaxis_title="Time [days]", yaxis_title="Altitude [km]")
            end
        end
    end
    plot_1 = plot(plot_traces_1, layout_1)

    # --- Heat Rate plot ---
    plot_traces_heat_rate = []
    layout_heat_rate = Layout(xaxis_title="Orbits", yaxis_title="Heat rate [W/cm^2]")
    for (i, id) in enumerate(ids)
        dt = data_table[id]
        for k in 1:length(config.model.body.links)
            col = Symbol("link_$(k)_heat_rate")
            if hasproperty(dt, col) || haskey(dt, col)
                index = findall(x -> x > 0, dt[!, col])
                if isempty(index)
                    index = 1:length(dt[!, col])
                end
                heat_rate = dt[!, col][index]
                time = [dt.time[j] for j in index]
                push!(plot_traces_heat_rate, scatter(x=time, y=heat_rate, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Heat Rate $id link $k"))
            end
        end
    end
    plot_heat_rate = plot(plot_traces_heat_rate, layout_heat_rate)

    # --- Heat Load plot ---
    plot_traces_heat_load = []
    layout_heat_load = Layout(xaxis_title="Orbits", yaxis_title="Heat load [J/cm^2]")
    for (i, id) in enumerate(ids)
        dt = data_table[id]
        for k in 1:length(config.model.body.links)
            col = Symbol("link_$(k)_heat_load")
            if hasproperty(dt, col) || haskey(dt, col)
                index = 1:length(dt[!, col])
                heat_load = dt[!, col][index]
                time = [dt.time[j] for j in index]
                push!(plot_traces_heat_load, scatter(x=time, y=heat_load, mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Heat Load $id link $k"))
            end
        end
    end
    plot_heat_load = plot(plot_traces_heat_load, layout_heat_load)

    # --- Mass or Dynamic Pressure plot ---
    plot_traces_4 = []
    layout_4 = nothing
    for (i, id) in enumerate(ids)
        dt = data_table[id]
        arg = args[id]
        if arg[:body_shape] == "Spacecraft"
            push!(plot_traces_4, scatter(x=[item/(60*60*24) for item in dt.time], y=[item - config.get_spacecraft_mass(m.body, m.body.roots[1], dry=true) for item in dt.mass], mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="Mass $id"))
            layout_4 = Layout(xaxis_title="Time [days]", yaxis_title="Mass [kg]")
        else
            if haskey(dt, :q)
                index = findall(x -> x > 0, dt.q)
                q = dt.q[index]
                time = [dt.time[j] for j in index]
                push!(plot_traces_4, scatter(x=time/(60*60*24), y=q, mode="markers", marker=attr(color=colors[i % length(colors) + 1]), name="Dynamic Pressure $id"))
                layout_4 = Layout(xaxis_title="Time [days]", yaxis_title="Dynamic pressure [Pa]")
            end
        end
    end
    plot_4 = plot(plot_traces_4, layout_4)

    # --- Combine all plots ---
    p = [plot_1 plot_heat_rate; plot_heat_load plot_4]
    relayout!(p, width=2100, height=1200, template="simple_white", showlegend=true)

    display(p)
    savefig(p, "multi_" * first(values(name)) * "_performance.pdf", format="pdf")
end

function traj_2D(state, m, name::Dict, args::Dict, data_table::Dict)
    ids = collect(keys(data_table))
    colors = ["black", "red", "blue", "green", "orange", "purple", "cyan", "magenta", "yellow"]

    plot_traces = []

    x_min, x_max = Inf, -Inf
    y_min, y_max = Inf, -Inf

    for (i, id) in enumerate(ids)
        dt = data_table[id]
        arg = args[id]
        n = name[id]

        x = dt.pos_ii_1 * 1e-3
        y = dt.pos_ii_2 * 1e-3
        z = dt.pos_ii_3 * 1e-3
        inc = dt.i[1]
        Ω = dt.OMEGA[1]
        ω = dt.omega[1]

        T_ijk = [cos(Ω)*cos(ω)-sin(Ω)*sin(ω)*cos(inc) sin(Ω)*cos(ω)+cos(Ω)*sin(ω)*cos(inc) sin(ω)*sin(inc);
                 -cos(Ω)*sin(ω)-sin(Ω)*cos(ω)*cos(inc) -sin(Ω)*sin(ω)+cos(Ω)*cos(ω)*cos(inc) cos(ω)*sin(inc);
                 sin(Ω)*sin(inc) -cos(Ω)*sin(inc) cos(inc)]

        vector = T_ijk * hcat(x, y, z)'

        x_min = min(x_min, minimum(vector[1,:]))
        x_max = max(x_max, maximum(vector[1,:]))
        y_min = min(y_min, minimum(vector[2,:]))
        y_max = max(y_max, maximum(vector[2,:]))

        push!(plot_traces, scatter(x=vector[1,:], y=vector[2,:], mode="lines", line=attr(color=colors[i % length(colors) + 1]), name="SC $id"))
    end

    min_val = minimum([x_min, y_min])
    max_val = maximum([x_max, y_max])

    x_labels = range(start=min_val, step=5000, stop=max_val)
    y_labels = range(start=min_val, step=5000, stop=max_val)

    # Use the first args for planet radii and EI
    first_arg = args[ids[1]]
    planet_e = m.planet.Rp_e * 1e-3
    planet_p = m.planet.Rp_p * 1e-3
    EI = first_arg[:EI]

    layout = Layout(
        width=800, height=800,
        xaxis_title="x [km]", yaxis_title="y [km]",
        xaxis_range=[min_val, max_val], yaxis_range=[min_val, max_val],
        shapes=[
            circle(xref="x", yref="y", fillcolor="OrangeRed",
                   x0=-planet_e, y0=-planet_p, x1=planet_e, y1=planet_p, line_color="OrangeRed"),
            circle(xref="x", yref="y", fillcolor="Yellow", opacity=0.2,
                   x0=-planet_e-EI, y0=-planet_e-EI, x1=planet_e+EI, y1=planet_e+EI, line_color="Yellow")
        ],
        template="simple_white", showlegend=true
    )

    p = plot(plot_traces, layout)
    display(p)
    savefig(p, first(values(name)) * "_traj2D.pdf", width=800, height=800, format="pdf")
end

function traj_3D(state, m, name::Dict, args::Dict, data_table::Dict)
    ids = collect(keys(data_table))

    # --- Generate planet sphere and AE sphere only once ---
    planet_radius = m.planet.Rp_e * 1e-3
    n = 100
    u = range(start=-pi, stop=pi, length=n)
    v = range(start=0, stop=pi, length=n)
    xs = planet_radius * cos.(u) * sin.(v)'
    ys = planet_radius * sin.(u) * sin.(v)'
    zs = planet_radius * ones(n) * cos.(v)'

    sphere1 = surface(x=xs, y=ys, z=zs, opacity=0.9, showscale=false, surfacecolor=@. xs^2 + ys^2 + zs^2 + 100)

    # Use the first spacecraft's args for AE altitude
    first_arg = args[ids[1]]
    r_ae = planet_radius + first_arg[:EI]
    xs_ae = r_ae * cos.(u) * sin.(v)'
    ys_ae = r_ae * sin.(u) * sin.(v)'
    zs_ae = r_ae * ones(n) * cos.(v)'

    sphere2 = surface(x=xs_ae, y=ys_ae, z=zs_ae, opacity=0.2, showscale=false, surfacecolor=@. xs_ae^2 + ys_ae^2 + zs_ae^2 - 100)

    # --- Collect all spacecraft trajectories ---
    traj_3D_traces = []
    axis_min, axis_max = Inf, -Inf

    for id in ids
        dt = data_table[id]
        arg = args[id]
        # Determine color by spacecraft id sign
        sc_id = tryparse(Int, id)
        color = (sc_id !== nothing && sc_id > 0) ? "blue" : "red"

        x = dt.pos_ii_1 * 1e-3
        y = dt.pos_ii_2 * 1e-3
        z = dt.pos_ii_3 * 1e-3

        # Find passage indices
        index = [1]
        for j in range(start=1, step=1, stop=length(dt.number_of_passage)-1)
            if dt.number_of_passage[j+1] - dt.number_of_passage[j] > 0
                append!(index, j)
            end
        end
        append!(index, length(dt.number_of_passage))

        # Update axis limits
        axis_min = min(axis_min, minimum([minimum(x), minimum(y), minimum(z), -(planet_radius + 250)]))
        axis_max = max(axis_max, maximum([maximum(x), maximum(y), maximum(z), (planet_radius + 250)]))

        # Plot each passage segment
        for k in range(start=1, step=1, stop=length(index)-1)
            if dt.number_of_passage[end] == 1
                x_s, y_s, z_s = x, y, z
            else
                x_s = x[index[k]:index[k+1]]
                y_s = y[index[k]:index[k+1]]
                z_s = z[index[k]:index[k+1]]
            end
            push!(traj_3D_traces, scatter3d(x=x_s, y=y_s, z=z_s, mode="lines", line=attr(color=color), name="SC $id"))
        end

        # Mark entry point if needed
        if arg[:type_of_mission] == "Entry"
            push!(traj_3D_traces, scatter3d(x=[x[1]], y=[y[1]], z=[z[1]], mode="markers", marker=attr(color=color, symbol="x"), name="Entry $id"))
        end
    end

    layout = Layout(
        scene_aspectmode="cube",
        scene_xaxis_range=[axis_min, axis_max],
        scene_yaxis_range=[axis_min, axis_max],
        scene_zaxis_range=[axis_min, axis_max],
        xaxis_title="x [km]", yaxis_title="y [km]", zaxis_title="z [km]",
        template="simple_white", showlegend=true
    )
    p = plot([sphere1, sphere2, traj_3D_traces...], layout)

    display(p)
    savefig(p, first(values(name)) * "_traj3D.pdf", format="pdf")

    # Push Plotly graph to dashboard
    comp_id = first(values(name)) * "_traj3d"
    upsert_trace!(
        args, comp_id,
        base_traces=[sphere1, sphere2, traj_3D_traces...],
        layout=layout
    )
end

function ABM_periapsis(name)
    orbit_number = config.cnf.orbit_number_list .- 1
    periapsis_altitude = config.cnf.periapsis_list
    delta_v = [0.0]

    delta_v_raise = []
    delta_v_lower = []

    for j in range(start=1, step=1, stop=length(config.cnf.Δv_list)-1)
        append!(delta_v, config.cnf.Δv_list[j+1] - config.cnf.Δv_list[j])
    end

    for j in range(start=1, step=1, stop=length(delta_v))
        if j in config.cnf.raise_man_orbit
            append!(delta_v_raise, delta_v[j])
        elseif j in config.cnf.lower_man_orbit
            append!(delta_v_lower, delta_v[j])
        end
    end

    plot_traces_palt = scatter(x=orbit_number, y=periapsis_altitude, mode="markers", marker=attr(color="black"))

    plot_traces_abm1 = scatter(x=[item for item in config.cnf.raise_man_orbit], y=delta_v_raise, mode="markers", marker=attr(color="blue", symbol="triangle"), yaxis="y2") # , label="ABM to raise periapsis")
    plot_traces_abm2 = scatter(x=[item for item in config.cnf.lower_man_orbit], y=delta_v_lower, mode="markers", marker=attr(color="red", symbol="circle"), yaxis="y2") # , label="ABM to lower periapsis")
    
    p = plot([plot_traces_palt, plot_traces_abm1, plot_traces_abm2], Layout(xaxis_title_text="Orbit", yaxis_title_text="Periapsis altitude [km]", yaxis2 = attr(title="ABM Magnitude [m/s]", overlaying="y", side="right"), template="simple_white", showlegend=false))

    display(p)
    savefig(p, name * "_Periapsis_alt_and_maneuvers.pdf", format="pdf")

end

function ground_track(state, m, name, args, data_table)
    """
        Plot the ground track of the spacecraft during the drag passages
    """
    time = data_table.time
    xaxis_title = ""
    if config.solution.orientation.number_of_passage[end] == 1 || args[:type_of_mission] == "Time"
        lats_traces = scatter(x=time, y=rad2deg.(data_table.lat), mode="lines", line=attr(color="black"))
        lons_traces = scatter(x=time, y=rad2deg.(data_table.lon), mode="lines", line=attr(color="black"))
        xaxis_title = "Time [s]"
    else
        lats_traces = scatter(x=1:maximum(config.solution.orientation.number_of_passage), y=config.cnf.latitude_periapsis, mode="lines", line=attr(color="black"))
        lons_traces = scatter(x=1:maximum(config.solution.orientation.number_of_passage), y=config.cnf.longitude_periapsis, mode="lines", line=attr(color="black"))
        xaxis_title = "Orbit number"
    end

    lats_plot = plot(lats_traces, Layout(xaxis_title=xaxis_title, yaxis_title="Latitude [deg]", template="simple_white", showlegend=false))
    lons_plot = plot(lons_traces, Layout(xaxis_title=xaxis_title, yaxis_title="Longitude [deg]", template="simple_white", showlegend=false))
    p = [lats_plot lons_plot]
    relayout!(p, width=1200, height=600, template="simple_white", showlegend=false)
    
    display(p)
    savefig(p, name * "_ground_track.pdf", format="pdf")

end

function attitude_plot(name, args, data_table)
    """
        Plot the attitude of the spacecraft during the drag passages
    """

    time = data_table.time
    q1 = data_table.q_1
    q2 = data_table.q_2
    q3 = data_table.q_3
    q4 = data_table.q_4
    euler_angles = zeros(3, length(time))
    @inbounds for i in 1:length(q1)
        quaternion = [q1[i], q2[i], q3[i], q4[i]]
        euler_angles[:, i] = qToEulerAngles(quaternion)
    end
    r_traces = scatter(x=time/60, y=rad2deg.(euler_angles[1,:]), mode="lines", line=attr(color="red"), name="Roll")
    p_traces = scatter(x=time/60, y=rad2deg.(euler_angles[2,:]), mode="lines", line=attr(color="green"), name="Pitch")
    y_traces = scatter(x=time/60, y=rad2deg.(euler_angles[3,:]), mode="lines", line=attr(color="blue"), name="Yaw")
    layout = Layout(xaxis_title="Time [min]", yaxis_title="Angle (Degrees)", template="simple_white", showlegend=true)
    p = plot([r_traces, p_traces, y_traces], layout)
    display(p)
    savefig(p, name * "_attitude.pdf", format="pdf")
end

function quaternion_plot(name, data_table)
    """
        Plot the quaternion of the spacecraft during the drag passages
    """

    time = data_table.time
    # quaternions = data_table.quaternion
    q1_traces = scatter(x=time/60, y=data_table.q_1, mode="lines", line=attr(color="red"), name="q1")
    q2_traces = scatter(x=time/60, y=data_table.q_2, mode="lines", line=attr(color="green"), name="q2")
    q3_traces = scatter(x=time/60, y=data_table.q_3, mode="lines", line=attr(color="blue"), name="q3")
    q4_traces = scatter(x=time/60, y=data_table.q_4, mode="lines", line=attr(color="orange"), name="q4")
    layout = Layout(xaxis_title="Time [min]", yaxis_title="Quaternion", template="simple_white", showlegend=true)
    p = plot([q1_traces, q2_traces, q3_traces, q4_traces], layout)
    display(p)
    savefig(p, name * "_quaternion.pdf", format="pdf")
end

function angular_velocity_plot(name, data_table)
    """
        Plot the angular velocity of the spacecraft during the drag passages
    """

    time = data_table.time
    # angular_velocity = data_table.ω
    ω1_traces = scatter(x=time/60, y=rad2deg.(data_table.omega_1)*60, mode="lines", line=attr(color="red"), name="ω1")
    ω2_traces = scatter(x=time/60, y=rad2deg.(data_table.omega_2)*60, mode="lines", line=attr(color="green"), name="ω2")
    ω3_traces = scatter(x=time/60, y=rad2deg.(data_table.omega_3)*60, mode="lines", line=attr(color="blue"), name="ω3")
    layout = Layout(xaxis_title="Time [min]", yaxis_title="Angular Velocity (deg/min)", template="simple_white", showlegend=true)
    p = plot([ω1_traces, ω2_traces, ω3_traces], layout)
    display(p)
    savefig(p, name * "_angular_velocity.pdf", format="pdf")
end

function wind_relative_attitude_plot(name, args, data_table)
    """
        Plot the angle of attack and sideslip angles
    """
    time = data_table.time
    # α = []
    # β = []
    # for i in 1:config.model.body.number_of_links
    #     if !haskey(data_table, Symbol("link_$(i)_aoa")) || !haskey(data_table, Symbol("link_$(i)_sideslip"))
    #         error("Data table does not contain link $i angle of attack or sideslip data.")
    #     end
    #     push!(α, data_table[:, Symbol("link_$(i)_aoa")])
    #     push!(β, data_table[:, Symbol("link_$(i)_sideslip")])
    # end
    α_traces = []
    β_traces = []
    α_control_traces = []
    color_choices = ["red", "green", "blue", "orange", "purple", "cyan", "magenta", "yellow", "black"]
    for i in eachindex(config.model.body.links)
        push!(α_traces, scatter(x=time, y=rad2deg.(data_table[:, Symbol("link_$(i)_aoa")]), mode="lines", line=attr(color=color_choices[i%length(color_choices) + 1]), name="α$i"))
        push!(β_traces, scatter(x=time, y=rad2deg.(data_table[:, Symbol("link_$(i)_sideslip")]), mode="lines", line=attr(color=color_choices[i%length(color_choices) + 1], dash="dash"), name="β$i"))
    end
    
    if args[:control_mode] != 0
        push!(α_control_traces, scatter(x=time, y=rad2deg.(data_table.aoa_control), mode="lines", line=attr(color="black", dash="dot"), name="α_control"))
    end
    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Angle (deg)", template="simple_white", showlegend=true)
    p = plot([α_traces..., β_traces..., α_control_traces...], layout)
    display(p)
    savefig(p, name * "_alpha_beta.pdf", format="pdf")
end

function reaction_wheel_h_plot(name, data_table)
    """
        Plot the reaction wheel angular momentum
    """
    time = config.solution.orientation.time
    h = config.solution.physical_properties.rw_h
    color_choices = ["red", "green", "blue", "orange", "purple", "cyan", "magenta", "yellow", "black"]
    h_traces = []
    
    for i in eachindex(h)
        push!(h_traces, scatter(x=time, y=h[i], mode="lines", line=attr(color=color_choices[i%length(color_choices)]), name="h$i"))
    end
    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Angular Momentum (kg*m²/s)", template="simple_white", showlegend=true)
    p = plot([h_traces...], layout)
    display(p)
    savefig(p, name * "_reaction_wheel_h.pdf", format="pdf")
end

function total_reaction_wheel_torque_plot(name, data_table)
    """
        Plot the reaction wheel torque
    """
    time = data_table.time
    τ = data_table[:, [:rw_torque_ii_1, :rw_torque_ii_2, :rw_torque_ii_3]]
    colors = ["red", "green", "blue"]
    τ_traces = []
    for (i, colvals) in enumerate(eachcol(τ))
        push!(τ_traces, scatter(x=time, y=colvals, mode="lines", line=attr(color=colors[i]), name="τ$i"))
    end
    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Torque (N*m)", template="simple_white", showlegend=true)
    p = plot([τ_traces...], layout)
    display(p)
    savefig(p, name * "_reaction_wheel_torque.pdf", format="pdf")
end

function reaction_wheel_torque_plot(name, data_table)
    """
        Plot the reaction wheel angular momentum
    """
    time = data_table.time
    τ = zeros(config.model.body.n_reaction_wheels, length(time))
    for i in 1:config.model.body.n_reaction_wheels
        # if !haskey(data_table, Symbol("rw_tau_ii_$(i)"))
        #     error("Data table does not contain rw_tau_ii_$(i) data.")
        # end
        τ[i, :] = data_table[!, Symbol("rw_tau_$(i)")]
    end
    color_choices = ["red", "green", "blue", "orange", "purple", "cyan", "magenta", "yellow", "black"]
    τ_traces = []
    
    for (i, rowvals) in enumerate(eachrow(τ))
        push!(τ_traces, scatter(x=time, y=rowvals, mode="lines", line=attr(color=color_choices[i%length(color_choices)]), name="τ$i"))
    end
    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Torque (N⋅m)", template="simple_white", showlegend=true)
    p = plot([τ_traces...], layout)
    display(p)
    savefig(p, name * "_reaction_wheel_tau.pdf", format="pdf")
end

function torque_plot(name, data_table)
    """
        Plot the total torque
    """
    time = data_table.time
    τ1 = data_table.tau_ii_1
    τ2 = data_table.tau_ii_2
    τ3 = data_table.tau_ii_3
    τ = [τ1, τ2, τ3]
    colors = ["red", "green", "blue"]
    τ_traces = []
    for i in eachindex(τ)
        push!(τ_traces, scatter(x=time, y=τ[i], mode="lines", line=attr(color=colors[i]), name="τ$i"))
    end
    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Torque (N⋅m)", template="simple_white", showlegend=true)
    p = plot([τ_traces...], layout)
    display(p)
    savefig(p, name * "_total_torque.pdf", format="pdf")
end

function inertia_plot(name, data_table)
    """
        Plot the inertia tensor
    """
    time = data_table.time
    I1 = data_table.J_ii_1
    I2 = data_table.J_ii_2
    I3 = data_table.J_ii_3
    I4 = data_table.J_ii_4
    I5 = data_table.J_ii_5
    I6 = data_table.J_ii_6
    I7 = data_table.J_ii_7
    I8 = data_table.J_ii_8
    I9 = data_table.J_ii_9

    traces = [
        scatter(x=time, y=I1, mode="lines", line=attr(color="red"), name="I1"),
        scatter(x=time, y=I2, mode="lines", line=attr(color="green"), name="I2"),
        scatter(x=time, y=I3, mode="lines", line=attr(color="blue"), name="I3"),
        scatter(x=time, y=I4, mode="lines", line=attr(color="orange"), name="I4"),
        scatter(x=time, y=I5, mode="lines", line=attr(color="purple"), name="I5"),
        scatter(x=time, y=I6, mode="lines", line=attr(color="cyan"), name="I6"),
        scatter(x=time, y=I7, mode="lines", line=attr(color="magenta"), name="I7"),
        scatter(x=time, y=I8, mode="lines", line=attr(color="yellow"), name="I8"),
        scatter(x=time, y=I9, mode="lines", line=attr(color="black"), name="I9")
    ]

    layout = Layout(xaxis_title="Time [sec]", yaxis_title="Inertia Tensor (kg⋅m²)", template="simple_white", showlegend=true)
    p = plot(traces, layout)
    display(p)
    savefig(p, name * "_inertia_tensor.pdf", format="pdf")
end